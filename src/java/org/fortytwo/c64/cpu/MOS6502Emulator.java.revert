package org.fortytwo.c64.cpu;

import org.fortytwo.c64.util.Ringbuffer;
import org.fortytwo.c64.util.PRGFile;
import java.io.File;

import org.fortytwo.c64.memory.Memory;
import org.fortytwo.c64.memory.ROM;

import java.io.BufferedReader;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.logging.Logger;
import java.util.logging.Level;
/**
 * Emulatores a MOS6502/6510
 */
public class MOS6502Emulator implements CPU
{
    public static final int INITIAL_ADDRESS = 0xFFFC; // pointer to reset vector in kernel
    public static final int IRQ_VECTOR_ADDRESS = 0xFFFE;

    public static final int REGISTER_COUNT = 6;
    private boolean interruptsDisabled;
    private boolean carryFlag;
    private boolean decimalFlag;
    private boolean zeroFlag;
    private boolean signFlag;
    private boolean overflowFlag;

    public static final int STATUS_FLAG_CARRY = 0x1;
    public static final int STATUS_FLAG_ZERO = 0x2;
    public static final int STATUS_FLAG_INTERRUPT = 0x4;
    public static final int STATUS_FLAG_DECIMAL = 0x8;
    public static final int STATUS_FLAG_BREAK = 0x16;
    public static final int STATUS_FLAG_OVERFLOW = 0x64;
    public static final int STATUS_FLAG_SIGN = 0x128;

    public static final int LOAD_RAM_ADDRESS = 0xF49E; // LOAD RAM from DEVICE
    public static final int SCROLL_SCREEN_ADDRESS = 0xE8EA;
    public static final int OPEN_DEVICE_ADDRESS = 0xF3D5;
    //    private int operands[] = new int[2]; // so we don't have to keep creating this...does it matter?
    public static final int EMULATED_CLOCK_SPEED = 1022700;
    private int[] registers = new int[REGISTER_COUNT];

    // Common addresses
    private static final int ADDRESS_CURRENT_SCREEN_LINE_ADDRESS = 0xD1;
    private static final int ADDRESS_CURSOR_LINE_NUMBER = 0xD6;
    private static final int ADDRESS_CURSOR_INPUT_X = 0xC9;
    private static final int ADDRESS_LINE_NUMBER_TEMP = 0x2A5;
    private static final int ADDRESS_TOP_OF_SCREEN_MEMORY = 0x288;
    private int breakAddress = -1;
    boolean keepRunning = true;
    boolean inBreakPoint = false;
    
    double elapsedTime = 0.0;
    long fetchElapsed;
    long decodeElapsed = 0;
    long executeElapsed = 0;
    long inputElapsed = 0;
    long loopCount = 0;
    long cycles = 0;

    private ArrayList<CycleObserver> observers;
	boolean shouldLog = true;
    //private Hashtable<RegisterType,Integer> registers;
    private Logger logger;
    private Memory memory;
    private Ringbuffer instructionBuffer;

    public MOS6502Emulator(){
        logger = Logger.getLogger(this.getClass().getName());
        //registers = new Hashtable<RegisterType,Integer>(RegisterType.values().length);
        interruptsDisabled = false;
        carryFlag = false;
        decimalFlag = false;
        zeroFlag = false;
        signFlag = false;
        overflowFlag = false;
        observers = new ArrayList<CycleObserver>();
        instructionBuffer = new Ringbuffer(20);
    }

    public void setMemory(Memory memory){
        this.memory = memory;
    }

    public void registerCycleObserver(CycleObserver observer){
        observers.add(observer);
    }

    public void setBreak(int address){
        this.breakAddress = address;
    }

    public void run(){
        if (memory == null){
            throw new RuntimeException("Memory must be initialized!");
        }
	
        //performBootupSequence();
        writeRegister(RegisterType.programCounter,memory.readWord(INITIAL_ADDRESS));

        int operands[] = new int[2];
        long start = 0;
        long end = 0;
        long fetchStart = 0;
        long fetchEnd = 0;
        boolean skipped = false;
        int cyclesUntilInterrupt = 0;
        int skippedCycles = 0;
        while (keepRunning){
            if (inBreakPoint){
                System.out.println("[-------- START CYCLE -------------]");
            }
            start = System.nanoTime();

            int pc = readRegister(RegisterType.programCounter);

            if (pc == breakAddress){
                inBreakPoint = true;
            }


            /** FETCH INSTRUCTION **/
            fetchStart = System.nanoTime();
            int opcode = 0xFF & memory.read(pc);
            //if (shouldLog && logger.isLoggable(Level.FINEST))
            //logger.finest(instruction.getAssembly());
	
            /** "DEOCOE" OPERANDS **/
	Instruction.AddressingMode mode = null;
switch (opcode){
case 0:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 1:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 5:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 6:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 8:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 9:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 10:{
mode = Instruction.AddressingMode.Accumulator;
}
break;
case 13:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 14:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 16:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 17:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 21:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 22:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 24:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 25:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 29:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 30:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 32:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 33:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 36:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 37:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 38:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 40:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 41:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 42:{
mode = Instruction.AddressingMode.Accumulator;
}
break;
case 44:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 45:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 46:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 48:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 49:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 53:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 54:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 56:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 57:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 61:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 62:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 64:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 65:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 69:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 70:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 72:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 73:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 74:{
mode = Instruction.AddressingMode.Accumulator;
}
break;
case 76:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 77:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 78:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 80:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 81:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 85:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 86:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 88:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 89:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 93:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 94:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 96:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 97:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 101:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 102:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 104:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 105:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 106:{
mode = Instruction.AddressingMode.Accumulator;
}
break;
case 108:{
mode = Instruction.AddressingMode.Indirect;
}
break;
case 109:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 110:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 112:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 113:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 117:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 118:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 120:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 121:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 125:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 126:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 129:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 132:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 133:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 134:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 136:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 138:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 140:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 141:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 142:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 144:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 145:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 148:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 149:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 150:{
mode = Instruction.AddressingMode.ZeroPageIndexedY;
}
break;
case 152:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 153:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 154:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 157:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 160:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 161:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 162:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 164:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 165:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 166:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 168:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 169:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 170:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 172:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 173:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 174:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 176:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 177:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 180:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 181:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 182:{
mode = Instruction.AddressingMode.ZeroPageIndexedY;
}
break;
case 184:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 185:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 186:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 188:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 189:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 190:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 192:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 193:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 196:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 197:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 198:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 200:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 201:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 202:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 204:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 205:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 206:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 208:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 209:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 213:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 214:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 216:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 217:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 221:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 222:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 224:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 225:{
mode = Instruction.AddressingMode.PreIndexedIndirect;
}
break;
case 228:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 229:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 230:{
mode = Instruction.AddressingMode.ZeroPageAbsolute;
}
break;
case 232:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 233:{
mode = Instruction.AddressingMode.Immediate;
}
break;
case 234:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 236:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 237:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 238:{
mode = Instruction.AddressingMode.Absolute;
}
break;
case 240:{
mode = Instruction.AddressingMode.Relative;
}
break;
case 241:{
mode = Instruction.AddressingMode.PostIndexedIndirect;
}
break;
case 245:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 246:{
mode = Instruction.AddressingMode.ZeroPageIndexedX;
}
break;
case 248:{
mode = Instruction.AddressingMode.Implied;
}
break;
case 249:{
mode = Instruction.AddressingMode.IndexedY;
}
break;
case 253:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
case 254:{
mode = Instruction.AddressingMode.IndexedX;
}
break;
default:
    {
        mode = Instruction.AddressingMode.Absolute;
        //        throw new RuntimeException("Unable to determine mode from opcode: " + opcode + " " + Integer.toHexString(opcode));
    }
}
        
            //if (shouldLog && logger.isLoggable(Level.FINEST))
            //logger.finest(mode.toString());
	
            // we always use the same operand data
            operands[0] = 0;
            operands[1] = 0;
            //int instructionData = opcode << 16;
            int numBytes = mode.getByteCount();
            //	    int[] operands = new int[numBytes];
            if (numBytes > 0){
                if (numBytes == 1){
                    operands[0] = memory.read(pc + 1);
                }
                else if (numBytes == 2){
                    int val = memory.readWord(pc + 1);
                    operands[0] = val & 0xFF;
                    operands[1] = (val & 0xFF00) >> 8;
                }
                /*
                  for (int i = 1; i <= numBytes; i++){
                  //instructionData |= ((0xFF & memory.read(pc + i)) << (8 * (2- i)));
                  operands[i-1] = 0xFF & memory.read(pc + i);
                  }
                */
	    
            }

            // REMOVE]
            if (pc == LOAD_RAM_ADDRESS){ // intercept BASIC load's call to LOAD RAM
                System.out.println("Intercepting LOADRAM");
                handleLoadRAMFromDevice();
                
                opcode = 0x60;
                //	    return bean;
            }
            
            else if (pc == SCROLL_SCREEN_ADDRESS){
                handleScrollScreen();
                
                opcode = 0x60;
            }
            //* [REMOVE
                        //	InstructionBean instructionBean = fetchAndDecodeInstruction(pc);

            pc = pc + 1 + numBytes; // move our PC to the next instruction
            writeRegister(RegisterType.programCounter,pc); // this can get overwritten by the instruction

            long decodeStart = System.nanoTime();
            // now, we apply the addressing mode (basically , follow any indirects or indexes)
            if (numBytes > 0){
                applyIndexing(mode, operands, pc);
		      
            }
	
            long decodeEnd = System.nanoTime();
            decodeElapsed += (decodeEnd - decodeStart);

	
            //	    InstructionBean instructionBean = fetchAndDecodeInstruction(pc);

            if (inBreakPoint){
                end = System.nanoTime();
                elapsedTime += (end - start);
	       
                //		System.out.println(Integer.toHexString(pc) + " " + instructionBean.instruction.getFullAssemblyLine(mode,instructionBean.operands));

                skipped = handleDebuggingBreakPoint();
                start = System.nanoTime();
            }


            boolean interrupted = false;


            if (! skipped){
                try {
                    long executeStart = System.nanoTime();
                    //int cycles_ = instructionBean.instruction.execute(operands, memory, this);
	int cycles_ = 0;
switch (opcode){
case 0:{
cycles_ = execute_BRK(mode, operands, memory, this);
}
break;
case 1:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 5:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 6:{
cycles_ = execute_ASL(mode, operands, memory, this);
}
break;
case 8:{
cycles_ = execute_PHP(mode, operands, memory, this);
}
break;
case 9:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 10:{
cycles_ = execute_ASL(mode, operands, memory, this);
}
break;
case 13:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 14:{
cycles_ = execute_ASL(mode, operands, memory, this);
}
break;
case 16:{
cycles_ = execute_BPL(mode, operands, memory, this);
}
break;
case 17:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 21:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 22:{
cycles_ = execute_ASL(mode, operands, memory, this);
}
break;
case 24:{
cycles_ = execute_CLC(mode, operands, memory, this);
}
break;
case 25:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 29:{
cycles_ = execute_ORA(mode, operands, memory, this);
}
break;
case 30:{
cycles_ = execute_ASL(mode, operands, memory, this);
}
break;
case 32:{
cycles_ = execute_JSR(mode, operands, memory, this);
}
break;
case 33:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 36:{
cycles_ = execute_BIT(mode, operands, memory, this);
}
break;
case 37:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 38:{
cycles_ = execute_ROL(mode, operands, memory, this);
}
break;
case 40:{
cycles_ = execute_PLP(mode, operands, memory, this);
}
break;
case 41:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 42:{
cycles_ = execute_ROL(mode, operands, memory, this);
}
break;
case 44:{
cycles_ = execute_BIT(mode, operands, memory, this);
}
break;
case 45:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 46:{
cycles_ = execute_ROL(mode, operands, memory, this);
}
break;
case 48:{
cycles_ = execute_BMI(mode, operands, memory, this);
}
break;
case 49:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 53:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 54:{
cycles_ = execute_ROL(mode, operands, memory, this);
}
break;
case 56:{
cycles_ = execute_SEC(mode, operands, memory, this);
}
break;
case 57:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 61:{
cycles_ = execute_AND(mode, operands, memory, this);
}
break;
case 62:{
cycles_ = execute_ROL(mode, operands, memory, this);
}
break;
case 64:{
cycles_ = execute_RTI(mode, operands, memory, this);
}
break;
case 65:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 69:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 70:{
cycles_ = execute_LSR(mode, operands, memory, this);
}
break;
case 72:{
cycles_ = execute_PHA(mode, operands, memory, this);
}
break;
case 73:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 74:{
cycles_ = execute_LSR(mode, operands, memory, this);
}
break;
case 76:{
cycles_ = execute_JMP(mode, operands, memory, this);
}
break;
case 77:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 78:{
cycles_ = execute_LSR(mode, operands, memory, this);
}
break;
case 80:{
cycles_ = execute_BVC(mode, operands, memory, this);
}
break;
case 81:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 85:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 86:{
cycles_ = execute_LSR(mode, operands, memory, this);
}
break;
case 88:{
cycles_ = execute_CLI(mode, operands, memory, this);
}
break;
case 89:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 93:{
cycles_ = execute_EOR(mode, operands, memory, this);
}
break;
case 94:{
cycles_ = execute_LSR(mode, operands, memory, this);
}
break;
case 96:{
cycles_ = execute_RTS(mode, operands, memory, this);
}
break;
case 97:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 101:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 102:{
cycles_ = execute_ROR(mode, operands, memory, this);
}
break;
case 104:{
cycles_ = execute_PLA(mode, operands, memory, this);
}
break;
case 105:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 106:{
cycles_ = execute_ROR(mode, operands, memory, this);
}
break;
case 108:{
cycles_ = execute_JMP(mode, operands, memory, this);
}
break;
case 109:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 110:{
cycles_ = execute_ROR(mode, operands, memory, this);
}
break;
case 112:{
cycles_ = execute_BVS(mode, operands, memory, this);
}
break;
case 113:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 117:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 118:{
cycles_ = execute_ROR(mode, operands, memory, this);
}
break;
case 120:{
cycles_ = execute_SEI(mode, operands, memory, this);
}
break;
case 121:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 125:{
cycles_ = execute_ADC(mode, operands, memory, this);
}
break;
case 126:{
cycles_ = execute_ROR(mode, operands, memory, this);
}
break;
case 129:{
cycles_ = execute_STA(mode, operands, memory, this);
}
break;
case 132:{
cycles_ = execute_STY(mode, operands, memory, this);
}
break;
case 133:{
cycles_ = execute_STA(mode, operands, memory, this);
}
break;
case 134:{
cycles_ = execute_STX(mode, operands, memory, this);
}
break;
case 136:{
cycles_ = execute_DEY(mode, operands, memory, this);
}
break;
case 138:{
cycles_ = execute_TXA(mode, operands, memory, this);
}
break;
case 140:{
cycles_ = execute_STY(mode, operands, memory, this);
}
break;
case 141:{
cycles_ = execute_STA(mode, operands, memory, this);
}
break;
case 142:{
cycles_ = execute_STX(mode, operands, memory, this);
}
break;
case 144:{
cycles_ = execute_BCC(mode, operands, memory, this);
}
break;
case 145:{
cycles_ = execute_STA(mode, operands, memory, this);
}
break;
case 148:{
cycles_ = execute_STY(mode, operands, memory, this);
}
break;
case 149:{
cycles_ = execute_STA(mode, operands, memory, this);
}
break;
case 150:{
cycles_ = execute_STX(mode, operands, memory, this);
}
break;
case 152:{
cycles_ = execute_TYA(mode, operands, memory, this);
}
break;
case 153:{
cycles_ = execute_STA(mode, operands, memory, this);
}
break;
case 154:{
cycles_ = execute_TXS(mode, operands, memory, this);
}
break;
case 157:{
cycles_ = execute_STA(mode, operands, memory, this);
}
break;
case 160:{
cycles_ = execute_LDY(mode, operands, memory, this);
}
break;
case 161:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 162:{
cycles_ = execute_LDX(mode, operands, memory, this);
}
break;
case 164:{
cycles_ = execute_LDY(mode, operands, memory, this);
}
break;
case 165:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 166:{
cycles_ = execute_LDX(mode, operands, memory, this);
}
break;
case 168:{
cycles_ = execute_TAY(mode, operands, memory, this);
}
break;
case 169:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 170:{
cycles_ = execute_TAX(mode, operands, memory, this);
}
break;
case 172:{
cycles_ = execute_LDY(mode, operands, memory, this);
}
break;
case 173:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 174:{
cycles_ = execute_LDX(mode, operands, memory, this);
}
break;
case 176:{
cycles_ = execute_BCS(mode, operands, memory, this);
}
break;
case 177:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 180:{
cycles_ = execute_LDY(mode, operands, memory, this);
}
break;
case 181:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 182:{
cycles_ = execute_LDX(mode, operands, memory, this);
}
break;
case 184:{
cycles_ = execute_CLV(mode, operands, memory, this);
}
break;
case 185:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 186:{
cycles_ = execute_TSX(mode, operands, memory, this);
}
break;
case 188:{
cycles_ = execute_LDY(mode, operands, memory, this);
}
break;
case 189:{
cycles_ = execute_LDA(mode, operands, memory, this);
}
break;
case 190:{
cycles_ = execute_LDX(mode, operands, memory, this);
}
break;
case 192:{
cycles_ = execute_CPY(mode, operands, memory, this);
}
break;
case 193:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 196:{
cycles_ = execute_CPY(mode, operands, memory, this);
}
break;
case 197:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 198:{
cycles_ = execute_DEC(mode, operands, memory, this);
}
break;
case 200:{
cycles_ = execute_INY(mode, operands, memory, this);
}
break;
case 201:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 202:{
cycles_ = execute_DEX(mode, operands, memory, this);
}
break;
case 204:{
cycles_ = execute_CPY(mode, operands, memory, this);
}
break;
case 205:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 206:{
cycles_ = execute_DEC(mode, operands, memory, this);
}
break;
case 208:{
cycles_ = execute_BNE(mode, operands, memory, this);
}
break;
case 209:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 213:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 214:{
cycles_ = execute_DEC(mode, operands, memory, this);
}
break;
case 216:{
cycles_ = execute_CLD(mode, operands, memory, this);
}
break;
case 217:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 221:{
cycles_ = execute_CMP(mode, operands, memory, this);
}
break;
case 222:{
cycles_ = execute_DEC(mode, operands, memory, this);
}
break;
case 224:{
cycles_ = execute_CPX(mode, operands, memory, this);
}
break;
case 225:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 228:{
cycles_ = execute_CPX(mode, operands, memory, this);
}
break;
case 229:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 230:{
cycles_ = execute_INC(mode, operands, memory, this);
}
break;
case 232:{
cycles_ = execute_INX(mode, operands, memory, this);
}
break;
case 233:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 234:{
cycles_ = execute_NOP(mode, operands, memory, this);
}
break;
case 236:{
cycles_ = execute_CPX(mode, operands, memory, this);
}
break;
case 237:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 238:{
cycles_ = execute_INC(mode, operands, memory, this);
}
break;
case 240:{
cycles_ = execute_BEQ(mode, operands, memory, this);
}
break;
case 241:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 245:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 246:{
cycles_ = execute_INC(mode, operands, memory, this);
}
break;
case 248:{
cycles_ = execute_SED(mode, operands, memory, this);
}
break;
case 249:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 253:{
cycles_ = execute_SBC(mode, operands, memory, this);
}
break;
case 254:{
cycles_ = execute_INC(mode, operands, memory, this);
}
break;
default:
    {
        cycles_ = execute_NOP(mode, operands, memory, this);
    }
}
                    cycles += cycles_;

		
                    executeElapsed += (System.nanoTime() - executeStart);

                    skippedCycles += cycles_;
		    
                    if (skippedCycles >= cyclesUntilInterrupt){
                        cyclesUntilInterrupt = notifyObservers(skippedCycles);
                        //    logger.info("Cycles Until Interrupt: " + cyclesUntilInterrupt);
                        if (cyclesUntilInterrupt == 0){
                            interrupted = true;
                        }
                        skippedCycles = 0;
		    
                    }

                }
                catch (InstructionException e){
                    e.printStackTrace();
                    return;
                }
            }
            skipped = false;
            end = System.nanoTime();
            elapsedTime += (end - start);

            if ((! interruptsDisabled) && interrupted){ // basically doing a JSR to the jump vector
                if (inBreakPoint){
                    System.out.println("[--- START IRQ ---]");
                }
                handleInterrupt();
                if (inBreakPoint){
                    System.out.println("[--- END IRQ   ---]");
                }
		    
            }
            loopCount++;

            if (inBreakPoint){
                System.out.println("[---------- END CYCLE ---------------]");
            }
        }
    }

public int execute_ADC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int val = toInt(operands);
	if (mode != Instruction.AddressingMode.Immediate){
	    val = memory.read(val);
	}
    val = val & 0xFF;
	int accum = 0xFF & readRegister(RegisterType.accumulator);
	
	int newVal = accum + val;	
	if (getCarryFlag()){
	    newVal++;
	}

	setOverflowFlag(((accum ^ val) & 0x80) != 0 && ((accum ^ newVal) & 0x80) != 0);
	//setCarryFlag((newVal & 0x100) != 0);
    setCarryFlag(newVal > 0xFF);
	setSignFlag((newVal & 0x80) != 0);
	setZeroFlag((newVal & 0xFF) == 0);
	writeRegister(RegisterType.accumulator,newVal & 0xFF);

	return 4;
}
public int execute_AND(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int accum = 0xFF & readRegister(RegisterType.accumulator);
        int value = 0;
        if (mode == Instruction.AddressingMode.Immediate){
            value = accum & toInt(operands);
        }
        else {
            value = accum & memory.read(toInt(operands));
        }
        writeRegister(RegisterType.accumulator,0xFF & value);
        setSignFlag((value & 0x80) != 0);
        setZeroFlag((value & 0xFF) == 0);
	return 4;
}
public int execute_ASL(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (mode == Instruction.AddressingMode.Accumulator){
	    int accum = 0xFF & readRegister(RegisterType.accumulator);
	    setCarryFlag(((accum & 0x80) != 0));
	    accum = accum << 1;
	    setZeroFlag((accum & 0xFF) == 0);
	    setSignFlag((accum & 0x80) != 0);
	    writeRegister(RegisterType.accumulator, 0xFF & accum);

	}
	else {
	    int val= 0xFF & memory.read(toInt(operands));
	    setCarryFlag(((val & 0x80) != 0));
	    val = val << 1;
	    setZeroFlag((val & 0xFF) == 0);
	    setSignFlag((val & 0x80) != 0);
	    memory.write(toInt(operands), 0xFF & val);
	}
	return 4;
}
public int execute_BCC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (! getCarryFlag()){
	    writeRegister(RegisterType.programCounter,toInt(operands));
	}
	return 4;
}
public int execute_BCS(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (getCarryFlag()){
	    writeRegister(RegisterType.programCounter,toInt(operands));
	}
	return 4;
}
public int execute_BEQ(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (getZeroFlag()){
	    writeRegister(RegisterType.programCounter,toInt(operands));
	}
	return 4;
}
public int execute_BIT(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = 0xFF & memory.read(toInt(operands));
        setSignFlag((val & 0x80) != 0); // bit 7 of original
        setOverflowFlag((val & 0x40) != 0); // bit 6 of original
        
        val = val & readRegister(RegisterType.accumulator);
        setZeroFlag((val & 0xFF) == 0);
        
	return 4;
}
public int execute_BMI(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (getSignFlag()){
	    writeRegister(RegisterType.programCounter, toInt(operands));
	}
	return 4;
}
public int execute_BNE(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (! getZeroFlag()){
	    writeRegister(RegisterType.programCounter,toInt(operands));
	}
	return 4;
}
public int execute_BPL(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (! getSignFlag()){
	    writeRegister(RegisterType.programCounter,toInt(operands));
	}
	return 4;
}
public int execute_BRK(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        return 1;
}
public int execute_BVC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if (! getOverflowFlag()){
	    writeRegister(RegisterType.programCounter, toInt(operands));
	}
	return 4;
}
public int execute_BVS(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	if ( getOverflowFlag()){
	    writeRegister(RegisterType.programCounter, toInt(operands));
	}
	return 4;
}
public int execute_CLC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	setCarryFlag(false);
	return 4;
}
public int execute_CLD(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	setDecimalFlag(false);
	return 4;
}
public int execute_CLI(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	setInterruptsDisabled(false);
	return 2;
}
public int execute_CLV(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	setOverflowFlag(false);
	return 4;
}
public int execute_CMP(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = toInt(operands);
        if (mode != Instruction.AddressingMode.Immediate){
            val = memory.read(val); // assume it's an address
        }
        val = val & 0xFF;

        int accum = 0xFF & readRegister(RegisterType.accumulator);
        int newVal = 0x1FF & (accum + (~val) + 1); // 2s complement addition
        //        int newVal = accum - val;
        setCarryFlag(newVal < 256);
        setSignFlag((newVal & 0x80) != 0);
        setZeroFlag((newVal & 0xFF) == 0);
        
	return 4;
}
public int execute_CPX(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = toInt(operands);
        if (mode != Instruction.AddressingMode.Immediate){
            val = 0xFF & memory.read(val); // assume it's an address
        }
        val = 0xFF & val;
        
        int x = 0xFF & readRegister(RegisterType.X);
        int newVal = 0x1FF & (x + (~val) + 1); // 2s complement addition
        //        int newVal = x - val;
        setCarryFlag(newVal < 256);
        setSignFlag((0x80 & newVal) != 0);
        setZeroFlag((newVal & 0xFF) == 0);
	return 4;
}
public int execute_CPY(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int val = toInt(operands);
	if (mode != Instruction.AddressingMode.Immediate){
	    val = 0xFF & memory.read(val); // assume it's an address
	}
    val = 0xFF & val;
	int y = 0xFF & readRegister(RegisterType.Y);
    int newVal = 0x1FF & (y + (~val) + 1); // 2s complement addition
        
	//int newVal = y - val;
	setCarryFlag(newVal < 256); // inverse of borrow
	setSignFlag((0x80 & newVal) != 0);
	setZeroFlag(newVal == 0);

	return 4;
}
public int execute_DEC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int addr = toInt(operands);
        int val = 0xFF & memory.read(addr);
        val = val - 1;
        setSignFlag((val & 0x80) != 0);
        setZeroFlag(val == 0);
        memory.write(addr, 0xFF & val);
        
	return 4;
}
public int execute_DEX(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int x = 0xFF & readRegister(RegisterType.X);
    x = x - 1;
	setZeroFlag(x == 0);
	setSignFlag((x & 0x80) != 0);
	writeRegister(RegisterType.X, x & 0xFF);

	return 4;
}
public int execute_DEY(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int y = 0xFF & readRegister(RegisterType.Y);
        y = y - 1;
        setZeroFlag(y == 0);
        setSignFlag((y & 0x80) != 0);
        writeRegister(RegisterType.Y, y & 0xFF);
        
	return 4;
}
public int execute_EOR(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int accum = 0xFF & readRegister(RegisterType.accumulator);
	int value = 0;
	if (mode == Instruction.AddressingMode.Immediate){
	    value = accum ^ toInt(operands);
	}
	else {
	    value = accum ^ memory.read(toInt(operands));
	}
	writeRegister(RegisterType.accumulator,0xFF & value);
	setSignFlag((value & 0x80) != 0);
	setZeroFlag((value & 0xFF) == 0);
	return 4;
}
public int execute_INC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int addr = toInt(operands);
	int val = memory.read(addr);
	val = (val + 1) & 0xFF;
	setSignFlag((val & 0x80) != 0);
	setZeroFlag(val == 0);
	memory.write(addr, (val & 0xFF));

	return 4;
}
public int execute_INX(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int x = 0xFF & readRegister(RegisterType.X);
	x = (x + 1) & 0xFF;
	setZeroFlag(x == 0);
	setSignFlag((x & 0x80) != 0);
	writeRegister(RegisterType.X,x);

	return 4;
}
public int execute_INY(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int y = 0xFF & readRegister(RegisterType.Y);
        y = (y + 1) & 0xFF;
        setZeroFlag(y == 0);
        setSignFlag((y & 0x80) != 0);
        writeRegister(RegisterType.Y,y);
        
	return 4;
}
public int execute_JMP(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        writeRegister(RegisterType.programCounter,toInt(operands));
	return 4;
}
public int execute_JSR(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int pc = readRegister(RegisterType.programCounter);
        int sp = readRegister(RegisterType.stackPointer);
        if (sp == 0){
            throw new StackOverflowException();
        }
        sp--; // go up one so that we can write out our stack
        memory.writeWord(sp | 0x100, pc - 1); // PC has already moved past our real current
        //	System.out.println("Saved " + Integer.toHexString(pc) + " to stack");
        sp--;
        //sp -= 2;
        /*
          memory.write(sp | 0x100, (byte)((pc >> 8) & 0xFF)); // hibyte
          sp--;
          memory.write(sp | 0x100, (byte)(pc & 0x00FF)); // lowbyte
          sp--; // stack points to the next empty spot
        */
        writeRegister(RegisterType.stackPointer, sp);
        writeRegister(RegisterType.programCounter,(0xFF & operands[0]) | ((0xFF & operands[1]) << 8));
        
	return 4;
}
public int execute_LDA(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = toInt(operands);
        if (mode != Instruction.AddressingMode.Immediate) { // memory
            val = memory.read(val);
        }
        writeRegister(RegisterType.accumulator, 0xFF & val);
        setZeroFlag((val & 0xFF) == 0);
        setSignFlag((val & 0x80) != 0);
	return 4;
}
public int execute_LDX(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = toInt(operands);
        if (mode != Instruction.AddressingMode.Immediate){
            val = 0xFF & memory.read(val);
        }
        setZeroFlag((val & 0xFF) == 0);
        setSignFlag((val & 0x80) != 0);
        writeRegister(RegisterType.X,val);
        
	return 4;
}
public int execute_LDY(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = toInt(operands);
        if (mode != Instruction.AddressingMode.Immediate){
            val = 0xFF & memory.read(val);
        }
        setZeroFlag((val & 0xFF) == 0);
        setSignFlag((val & 0x80) != 0);
        writeRegister(RegisterType.Y,0xFF & val);
        
	return 4;
}
public int execute_LSR(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
       if (mode == Instruction.AddressingMode.Accumulator){
           int accum = 0xFF & readRegister(RegisterType.accumulator);
           setCarryFlag(((accum & 0x01) != 0));
           accum = accum >> 1;
           setZeroFlag((accum & 0xFF) == 0);
           writeRegister(RegisterType.accumulator, 0xFF & accum);
           
       }
       else {
           int val= 0xFF & memory.read(toInt(operands));
           setCarryFlag(((val & 0x01) != 0));
           val = val >> 1;
           setZeroFlag((val & 0xFF) == 0);
           memory.write(toInt(operands), val & 0xFF);
       }
       setSignFlag(false);
	return 4;
}
public int execute_NOP(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	return 2;
}
public int execute_ORA(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int accum = readRegister(RegisterType.accumulator);
        int value = toInt(operands);
        if (mode != Instruction.AddressingMode.Immediate){
            value = memory.read(toInt(operands));
        }
        value = 0xFF & value;
        value = accum | value;
        writeRegister(RegisterType.accumulator,value);
        setSignFlag((value & 0x80) != 0);
        setZeroFlag((value & 0xFF) == 0);
	return 4;
}
public int execute_PHA(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        pushStack((byte) readRegister(RegisterType.accumulator));
        return 3;
}
public int execute_PHP(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        pushStack((byte) readRegister(RegisterType.status));
        
        return 3;
}
public int execute_PLA(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int accum = 0xFF & popStack();
        setSignFlag((accum & 0x80) != 0);
        setZeroFlag((accum & 0xFF) == 0);
        writeRegister(RegisterType.accumulator, accum);
        return 3;
}
public int execute_PLP(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int status = popStack();
        writeRegister(RegisterType.status, status);
        return 3;
}
public int execute_ROL(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = 0;
        if (mode == Instruction.AddressingMode.Accumulator){ // accumulator
            val = 0xFF & readRegister(RegisterType.accumulator);
        }
        else {
            val = 0xFF & memory.read(toInt(operands));
        }
        int oldval = val;
        val = val << 1;
        if (getCarryFlag()){
            val |= 0x1; // bring over the previous carry
        }
        setCarryFlag((oldval & 0x80) != 0);
        setSignFlag((val & 0x80) != 0);
        setZeroFlag((val & 0xFF) == 0);
        
        if (mode == Instruction.AddressingMode.Accumulator){
            writeRegister(RegisterType.accumulator, (val & 0xFF));
        }
        else {
            memory.write(toInt(operands),val & 0xFF);
        }
        
	return 4;
}
public int execute_ROR(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = 0;
        if (mode == Instruction.AddressingMode.Accumulator){ // accumulator
            val = 0xFF & readRegister(RegisterType.accumulator);
        }
        else {
            val = 0xFF & memory.read(toInt(operands));
        }
        int oldval = val;
        if (getCarryFlag()){
            val |= 0x100; // bring over the previous carry
        }
        setCarryFlag((val & 0x01) != 0);
        val = val >> 1;
        setSignFlag((val & 0x80) != 0);
        setZeroFlag((val & 0xFF) == 0);
        
        if (mode == Instruction.AddressingMode.Accumulator){
            writeRegister(RegisterType.accumulator,val & 0xFF);
        }
        else {
            memory.write(toInt(operands),val & 0xFF);
        }
        
	return 4;
}
public int execute_RTI(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int status = popStack();
        writeRegister(RegisterType.status, status);
        int sp = readRegister(RegisterType.stackPointer);
        
        sp++;
        writeRegister(RegisterType.programCounter, memory.readWord(sp | 0x100));
        sp++;
        writeRegister(RegisterType.stackPointer, sp);
        
        return 3;
}
public int execute_RTS(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int sp = readRegister(RegisterType.stackPointer);
        sp++;
        int returnAddress = memory.readWord(sp | 0x100);
        returnAddress++; // what's stored is actually the most recent byte
        sp++;
        writeRegister(RegisterType.stackPointer, sp);
        writeRegister(RegisterType.programCounter, returnAddress);
	return 4;
}
public int execute_SBC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        int val = toInt(operands);
        if (mode != Instruction.AddressingMode.Immediate){
            val = memory.read(val);
        }
        
        val = val & 0xFF;
        int accum = 0xFF & readRegister(RegisterType.accumulator);
        //int newVal = 0x1FF & ((accum - val - (getCarryFlag() ? 0 : 1))); // carry flag is inverse borrow
        int newVal = 0x1FF & (accum + (~val) + (getCarryFlag() ? 1 : 0)); // 2s complement addition
        setCarryFlag(newVal < 256);
        setSignFlag((newVal & 0x80) != 0);
        setZeroFlag((newVal & 0xFF) == 0);
        setOverflowFlag(((accum ^ newVal) & 0x80) != 0 && ((accum ^ val) & 0x80) != 0); /* check to see if the
                                                                                               new value has a different
                                                                                               sign than the accumulator
                                                                                               and the sign of the 
                                                                                               accumulator and the 
                                                                                               original value was different*/
        writeRegister(RegisterType.accumulator,newVal & 0xFF);
        
	return 4;
}
public int execute_SEC(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        setCarryFlag(true);
        return 2;
}
public int execute_SED(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	setDecimalFlag(true);
	return 4;
}
public int execute_SEI(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        // this is currently going to not optimal, but we'll optimize as necessary
        setInterruptsDisabled(true);
        
        return 2;
}
public int execute_STA(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        memory.write(toInt(operands), 0xFF & readRegister(RegisterType.accumulator));
        
	return 4;
}
public int execute_STX(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
        memory.write(toInt(operands), 0xFF & readRegister(RegisterType.X));

	return 4;
}
public int execute_STY(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	memory.write(toInt(operands), 0xFF & readRegister(RegisterType.Y));

	return 4;
}
public int execute_TAX(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int accum = readRegister(RegisterType.accumulator);
	setSignFlag((accum & 0x80) != 0);
	setZeroFlag((0xFF & accum) == 0);
	writeRegister(RegisterType.X,accum);

	return 4;
}
public int execute_TAY(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int accum = readRegister(RegisterType.accumulator);
	setSignFlag((accum & 0x80) != 0);
	setZeroFlag((0xFF & accum) == 0);
	writeRegister(RegisterType.Y,accum);

	return 4;
}
public int execute_TSX(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
      int sp = readRegister(RegisterType.stackPointer);
      writeRegister(RegisterType.X, 0xFF & sp);
      setSignFlag((sp & 0x80) != 0);
      setZeroFlag((sp & 0xFF) == 0);
	return 4;
}
public int execute_TXA(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int X = readRegister(RegisterType.X);
	writeRegister(RegisterType.accumulator, X & 0xFF);
	setSignFlag((X & 0x80) != 0);
	setZeroFlag((X & 0XFF) == 0);
	
	return 4;
}
public int execute_TXS(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	writeRegister(RegisterType.stackPointer, readRegister(RegisterType.X));

	return 4;
}
public int execute_TYA(Instruction.AddressingMode mode, int[] operands, Memory memory, CPU cpu){
	int Y = 0xFF & readRegister(RegisterType.Y);
	writeRegister(RegisterType.accumulator,Y);
	setSignFlag((Y & 0x80) != 0);
	setZeroFlag((Y & 0xFF) == 0);
	
	return 4;
}

    private void handleInterrupt(){
        interruptsDisabled = true;
        int irqAddress = memory.readWord(IRQ_VECTOR_ADDRESS);
        int progCounter = readRegister(RegisterType.programCounter);
        pushStack((byte)((progCounter & 0xFF00) >> 8));
        pushStack((byte)((progCounter & 0xFF)));
        int status = getCarryFlag() ? STATUS_FLAG_CARRY : 0x00;
        status |= getZeroFlag() ? STATUS_FLAG_ZERO : 0x00;
        status |= getDecimalFlag() ? STATUS_FLAG_DECIMAL : 0x00;
        status |= getSignFlag() ? STATUS_FLAG_SIGN : 0x00;
	
        pushStack((byte)status);
	
        writeRegister(RegisterType.programCounter, irqAddress);
   
        //inBreakPoint = true;
        //handleDebuggingBreakPoint();
	
    }
    private int notifyObservers(int cycles){
        //	logger.info("Notifying observers of " + cycles + " cycles" );
        int untilInterrupt = 9999999;
        for (CycleObserver observer : observers){
            int tmp = observer.tick(cycles);
            //  logger.info(observer.getClass().getName() + " cycles: " + tmp);
            if (tmp != -1 && tmp < untilInterrupt){
                untilInterrupt = tmp;
            }
            /*            if (tmp == 0 && ! interruptsDisabled){
                System.out.println("Interrupted by: " + observer.getClass().getName());
            }
            */
        }
        return untilInterrupt;
    }
    private void clearRegisters(){
        for (int i = 0; i < REGISTER_COUNT; i++){
            registers[i] = 0;
        }
    }

    private void displayRegisters(){
        StringBuffer buf = new StringBuffer();
        buf.append("PC=").append(Integer.toHexString(registers[RegisterType.programCounter])).append(",");
        buf.append("SP=").append(Integer.toHexString(registers[RegisterType.stackPointer])).append(",");
        buf.append("A=").append(Integer.toHexString(registers[RegisterType.accumulator])).append(",");
        buf.append("X=").append(Integer.toHexString(registers[RegisterType.X])).append(",");
        buf.append("Y=").append(Integer.toHexString(registers[RegisterType.Y])).append(",");
        buf.append("Z=").append(getZeroFlag()).append(",");
        buf.append("C=").append(getCarryFlag()).append(",");
        buf.append("S=").append(getSignFlag()).append(",");
        buf.append("O=").append(getOverflowFlag());
        logger.info("REGISTERS: " + buf);
    }

    protected void applyIndexing(Instruction.AddressingMode mode, int[] operands, int pc){
        switch (mode){
        case IndexedX:
        case ZeroPageIndexedX:
            {
                int addr = toInt(operands);
                addr += readRegister(RegisterType.X);
                operands[0] = (addr & 0xFF);
                operands[1] = (addr & 0xFF00) >> 8;
            }
            break;
        case IndexedY:
        case ZeroPageIndexedY:
            {
                int addr = toInt(operands);
                addr += readRegister(RegisterType.Y);
                operands[0] = (addr & 0xFF);
                operands[1] = (addr & 0xFF00) >> 8;
		
            }
            break;
        case Relative: // signed
            int newval = (byte)operands[0] + pc;
            operands[0] = newval & 0xFF;
            operands[1] = (newval & 0xFF00) >> 8;
            break;
        case Indirect:
            {
                int addr = toInt(operands);
		
                int val = memory.readWord(addr);
                //                System.out.println("Indirect address: " + Integer.toHexString(val));
                operands[0] = val & 0xFF;
                operands[1] = ((val & 0xFF00) >> 8);
            }
            break;
        case PreIndexedIndirect:
            {
                int addr = (operands[0] + readRegister(RegisterType.X)) % 0xFF;
                int val = memory.readWord(addr);
		
                operands[0] = val & 0xFF;
                operands[1] = (val & 0xFF00) >> 8;
            }
            break;
        case PostIndexedIndirect:
            {
                int addr = operands[0];
                int val = 0xFFFF & memory.readWord(addr);
                val = val + (0xFF & readRegister(RegisterType.Y));
                operands[0] = val & 0xFF;
                operands[1] = (val & 0xFF00) >> 8;
            }
            break;
        }
	
    }

    /**
     * NOTE: This method will update the ProgramCounter 
     */
    protected InstructionBean fetchAndDecodeInstruction(int pc){
	if (pc == LOAD_RAM_ADDRESS){ // intercept BASIC load's call to LOAD RAM
	    System.out.println("Intercepting LOADRAM");
	    handleLoadRAMFromDevice();
	    InstructionBean bean = new InstructionBean(pc, InstructionSet.getByOpCode(0x60), new int[0]);
	    return bean;
	}
	else if (pc == OPEN_DEVICE_ADDRESS) { // intercept serial open
	    System.out.println("Intercepting serial open");
	    InstructionBean bean = new InstructionBean(pc, InstructionSet.getByOpCode(0x60), new int[0]);
	    return bean;
	}

	int[] operands = new int[2];
	long fetchStart = System.nanoTime();
	int opcode = 0xFF & memory.read(pc);
	Instruction instruction = InstructionSet.getByOpCode(opcode);
	long fetchEnd = System.nanoTime();
	fetchElapsed += (fetchEnd - fetchStart);
	if (instruction == null){
	    System.err.println("Unknown opcode: " + Integer.toHexString(opcode));
	    return null;
	}
	
	//if (shouldLog && logger.isLoggable(Level.FINEST))
	//logger.finest(instruction.getAssembly());
	
        /** "DEOODE" OPERANDS **/
        Instruction.AddressingMode mode = instruction.getAddressingMode();
        //if (shouldLog && logger.isLoggable(Level.FINEST))
        //logger.finest(mode.toString());
	
        // we always use the same operand data
        operands[0] = 0;
        operands[1] = 0;
        //int instructionData = opcode << 16;
        int numBytes = mode.getByteCount();
        //	    int[] operands = new int[numBytes];
        if (numBytes > 0){
            if (numBytes == 1){
                operands[0] = memory.read(pc + 1);
            }
            else if (numBytes == 2){
                int val = memory.readWord(pc + 1);
                operands[0] = val & 0xFF;
                operands[1] = (val & 0xFF00) >> 8;
            }
            /*
              for (int i = 1; i <= numBytes; i++){
              //instructionData |= ((0xFF & memory.read(pc + i)) << (8 * (2- i)));
              operands[i-1] = 0xFF & memory.read(pc + i);
              }
            */
	    
        }

        InstructionBean bean = new InstructionBean(pc, instruction, operands);
        pc = pc + 1 + numBytes; // move our PC to the next instruction
        writeRegister(RegisterType.programCounter,pc); // this can get overwritten by the instruction

        long decodeStart = System.nanoTime();
        // now, we apply the addressing mode (basically , follow any indirects or indexes)
        if (numBytes > 0){
            switch (mode){
            case IndexedX:
            case ZeroPageIndexedX:
                {
                    int addr = toInt(operands);
                    addr += readRegister(RegisterType.X);
                    operands[0] = (addr & 0xFF);
                    operands[1] = (addr & 0xFF00) >> 8;
                }
                break;
            case IndexedY:
            case ZeroPageIndexedY:
                {
                    int addr = toInt(operands);
                    addr += readRegister(RegisterType.Y);
                    operands[0] = (addr & 0xFF);
                    operands[1] = (addr & 0xFF00) >> 8;
		    
                }
                break;
            case Relative: // signed
                int newval = (byte)operands[0] + pc;
                operands[0] = newval & 0xFF;
                operands[1] = (newval & 0xFF00) >> 8;
                break;
            case Indirect:
                {
                    int addr = toInt(operands);
		    
                    int val = memory.readWord(addr);
                    System.out.println("Indirect address: " + Integer.toHexString(val));
                    operands[0] = val & 0xFF;
                    operands[1] = ((val & 0xFF00) >> 8);
                }
                break;
            case PreIndexedIndirect:
                {
                    int addr = (operands[0] + readRegister(RegisterType.X)) % 0xFF;
                    int val = memory.readWord(addr);
		    
                    operands[0] = val & 0xFF;
                    operands[1] = (val & 0xFF00) >> 8;
                }
                break;
            case PostIndexedIndirect:
                {
                    int addr = operands[0];
                    int val = 0xFFFF & memory.readWord(addr);
                    val = val + (0xFF & readRegister(RegisterType.Y));
                    operands[0] = val & 0xFF;
                    operands[1] = (val & 0xFF00) >> 8;
                }
                break;
            }
        }
	
        long decodeEnd = System.nanoTime();
        decodeElapsed += (decodeEnd - decodeStart);


        return bean;
    }

    public int readRegister(int rt){
        //if (shouldLog && logger.isLoggable(Level.FINEST))
        //  logger.finest("Reading from register: " + rt);
        if (rt == RegisterType.status){
            return registers[rt] | 0x32; // unused flag
        }
        else return registers[rt];
    }

    public void writeRegister(int rt, int value){
        //	if (shouldLog && logger.isLoggable(Level.FINEST))
        //  logger.finest("Writing to register " + rt + ": " + value + "(" + Integer.toHexString(value));
        registers[rt] = value;
        if (rt == RegisterType.status){
            setCarryFlag((value & STATUS_FLAG_CARRY) != 0);
            setZeroFlag((value & STATUS_FLAG_ZERO) != 0);
            setInterruptsDisabled((value & STATUS_FLAG_INTERRUPT) != 0);
            setSignFlag((value & STATUS_FLAG_SIGN) != 0);
            setDecimalFlag((value & STATUS_FLAG_DECIMAL) != 0);
            setOverflowFlag((value & STATUS_FLAG_OVERFLOW) != 0);

        }
    }

    public void setInterruptsDisabled(boolean disabled){
        if (disabled){
            registers[RegisterType.status] |= STATUS_FLAG_INTERRUPT;
        }
        else {
            registers[RegisterType.status] &= (~STATUS_FLAG_INTERRUPT);
        }
        interruptsDisabled = disabled;
    }
    
    public void setCarryFlag(boolean carry){
        this.carryFlag = carry;
        if (carry){
            registers[RegisterType.status] |= STATUS_FLAG_CARRY;
        }
        else {
            registers[RegisterType.status] &= (~STATUS_FLAG_CARRY);
        }
    }

    public boolean getCarryFlag(){
        return carryFlag;
    }

    public void setDecimalFlag(boolean decimal){
        if (decimal){
            registers[RegisterType.status] |= STATUS_FLAG_DECIMAL;
        }
        else {
            registers[RegisterType.status] &= (~STATUS_FLAG_DECIMAL);
        }
        this.decimalFlag = decimal;
    }

    public boolean getDecimalFlag(){
        return decimalFlag;
    }

    public void setZeroFlag(boolean zero){
        if (zero){
            registers[RegisterType.status] |= STATUS_FLAG_ZERO;
        }
        else {
            registers[RegisterType.status] &= (~STATUS_FLAG_ZERO);
        }
        this.zeroFlag = zero;
    }

    public boolean getZeroFlag(){
        return zeroFlag;
    }

    public void setSignFlag(boolean signed){
        if (signed){
            registers[RegisterType.status] |= STATUS_FLAG_SIGN;
        }
        else {
            registers[RegisterType.status] &= (~STATUS_FLAG_SIGN);
        }
        this.signFlag = signed;
    }

    public boolean getSignFlag(){
        return signFlag;
    }

    public void setOverflowFlag(boolean overflow){
        if (overflow){
            registers[RegisterType.status] |= STATUS_FLAG_OVERFLOW;
        }
        else {
            registers[RegisterType.status] &= (~STATUS_FLAG_OVERFLOW);
        }
        this.overflowFlag = overflow;
    }
    
    public boolean getOverflowFlag(){
        return overflowFlag;
    }


    private boolean handleDebuggingBreakPoint() {
		displayRegisters();
		try {
		    boolean done = true;
		    while (true){
                System.out.print(">");
                BufferedReader bufferedIn = new BufferedReader(new java.io.InputStreamReader(System.in));
                String line = null;
                while ((line = bufferedIn.readLine()) == null){}
                if (line.startsWith("callstack")){
                    InstructionBean trace = (InstructionBean)instructionBuffer.getFirst();
                    while (trace != null){
                        trace.display();
                        trace = (InstructionBean)instructionBuffer.getNext();
                    }
			
                }
                else if (line.startsWith("c")){
                    inBreakPoint = false;
                    breakAddress = -1;
                    return false;
                }
                else if (line.startsWith("g")){ // run until new address
                    inBreakPoint = false;
                    breakAddress = Integer.parseInt(line.substring(1),16);
                    return false;
                }
                else if (line.indexOf("stack") != -1){
                    System.out.println("-- STACK --");
                    int i = registers[RegisterType.stackPointer];
                    i++;
                    while (i <= 255){
                        System.out.println(Integer.toHexString(memory.read(i | 0x100)));
                        i++;
                    }
                    System.out.println("[--------]");
			     
                }
                else if (line.indexOf("dumpram") != -1){
                    String[] params = line.split(" ");
                    int start = Integer.parseInt(params[1],16);
                    int end = Integer.parseInt(params[2],16);
                    String filename = params[3];
                    memory.dump(start,end,filename);
                }
                /* loads a raw RAM file, assumes that first 2 bytes specify location*/
                else if (line.indexOf("loadraw") != -1){
                    String[] params = line.split(" ");
                    String filename = params[1];
                    ROM rom = new ROM(filename,new File(filename));
                    byte[] data = rom.getRaw();
                    for (int i = 0; i < data.length-2; i++){
                        memory.write(0x801 + i,0xFF & data[i+2]);
                    }
                    memory.write(0xBA,8); // set device number
                    System.out.println("Loaded " + filename + " at " + Integer.toHexString(0x801));
                }
                else if (line.indexOf("loadprg") != -1){
                        String[] params = line.split(" ");
                        String filename = params[1];
                        PRGFile prgFile = new PRGFile(new File(filename));
                        memory.write(prgFile.getStartAddress(),prgFile.getData());
                        memory.write(0xBA,8); // set device number
                        System.out.println("Loaded " + prgFile.getFilename() + " at " + Integer.toHexString(prgFile.getStartAddress()));
                    }
                else if (line.indexOf("read") != -1){
                    String[] params = line.split(" ");
                    System.out.println(memory.read(Integer.parseInt(params[1],16)));
                }
                else if (line.startsWith("skipped")){ // skip current instruction
                    return true;
                }
                else if (line.startsWith("setreg")){
                    String[] params = line.split(" ");
                    String reg = params[1];
                    int val = Integer.parseInt(params[2]);
                    if (("X").equalsIgnoreCase(reg)){
                        registers[RegisterType.X] = val;
                    }
                    else if (("Y").equalsIgnoreCase(reg)){
                        registers[RegisterType.Y] = val;
                    }
                    else if (("C").equalsIgnoreCase(reg)){
                        setCarryFlag(1 == val);
                    }
                }
                                                   
                else if (line.startsWith("s")){ // stop
                    keepRunning = false;
                    return false;
                }
                else if (line.indexOf("nolog") != -1){
                    shouldLog = false;
                    memory.disableLogging();
                }
                else if (line.indexOf("dolog") != -1){
                    shouldLog = true;
                    memory.enableLogging();
                }
                else if (line.indexOf("time") != -1){
                    StringBuffer cpuLine = new StringBuffer();
                    double micros = elapsedTime / 1000.0;
                    cpuLine.append("Elapsed: ").append(micros);
                    cpuLine.append(" Average(ms): ").append(micros / loopCount);
                    double decodeMicros = decodeElapsed / 1000.0;
                    cpuLine.append(" Avg FetchDecode(ms): ").append(decodeMicros/loopCount);

                    double fetchMicros = fetchElapsed / 1000.0;
                    cpuLine.append(" Avg Fetch(ms): ").append(fetchMicros/loopCount);

                    double executeMicros = executeElapsed / 1000.0;
                    cpuLine.append(" Avg Execute(ms): ").append(executeMicros/loopCount);
                    double loopFreq = loopCount / (micros / 1000000.0);

                    double inputMicros = inputElapsed / 1000.0;
                    cpuLine.append(" Avg Input(ms): ").append(inputMicros/loopCount);
                    cpuLine.append(" Loop Freq: ").append(loopFreq);
                    cpuLine.append(" Cycle FReq: ").append(cycles / (micros / 1000000));
                    //			cpuLine.append(" Average Memory Read(us): ").append(memory.getAverageReadTime());
                    System.out.println(cpuLine.toString());
                }
                else if (line.startsWith("n") || line.trim().equals("")){ // run next instruction
                    return false;
                }
		    }
		    
		}
		catch (java.io.IOException e){
		}
		return false;

    }

    void pushStack(byte val){
        int sp = readRegister(RegisterType.stackPointer);
        memory.write(sp | 0x100, (byte)(val & 0xFF));
        sp--;
        writeRegister(RegisterType.stackPointer, sp);
    }

    int popStack(){
        int sp = readRegister(RegisterType.stackPointer);
        sp++;
        writeRegister(RegisterType.stackPointer, sp);
        return 0xFF & memory.read(sp | 0x100);
    }
    
    // currently assumes "RAW", but could just go off the extension...
    private void handleLoadRAMFromDevice(){
        int start = registers[RegisterType.X] | (registers[RegisterType.Y] << 8);
        int filenameLen = memory.read(0xB7);
        System.out.println("Filename len: " + filenameLen);
        byte[] fileBytes = new byte[filenameLen];
        int fileStart = memory.readWord(0xBB);
        System.out.println("File start: " + Integer.toHexString(fileStart));
        for (int i = 0; i < filenameLen; i++){
            fileBytes[i] = (byte)memory.read(fileStart+i);
            System.out.println("Read " + Integer.toHexString(memory.read(fileStart+i)));
        }
        String filename = new String(fileBytes);
        File file = new File("roms/tsuite/Testsuite/" + filename);
        System.out.println("Start = " + Integer.toHexString(start) + " name = " + filename);
        try {
            ROM rom = new ROM(filename, file);
            byte[] data = rom.getRaw();
            for (int i = 0; i < data.length-2; i++){
                memory.write(start + i,0xFF & data[i+2]);
            }
            //writeRegister(RegisterType.X,(start + (data.length -2)) & 0xFF);
            //writeRegister(RegisterType.Y,(start + (data.length -2)) >> 8);
        }
        catch (Exception e){
            e.printStackTrace();
        }
    }

    //** E9C8 move on screen line
    private void handleMoveOneScreenLine(){
        int accum = readRegister(RegisterType.accumulator);
        accum &= 0x03;
        accum |= memory.read(ADDRESS_TOP_OF_SCREEN_MEMORY);
        memory.write(0xAD, accum); // E9CD

        int currentColorRamAddress = memory.read(0xF3) | (memory.read(0xF4) << 8);
        int currentScreenLineAddress = memory.read(ADDRESS_CURRENT_SCREEN_LINE_ADDRESS) | (memory.read(0xD2) << 8);
        handleSetColorAndScreenAddresses(currentScreenLineAddress); // E9C5 JSR E9E0
        
        int address = memory.read(0xAC) | (memory.read(0xAD) << 8); // E9D4
        int address2 = memory.read(0xAE) | (memory.read(0xAF) << 8); // E9D8
        
        
        // E9D2 - E9DD
        for (int col = 39; col >= 0; col--){
            memory.write(currentScreenLineAddress + col, memory.read(address + col));
            memory.write(currentColorRamAddress + col, memory.read(address2 + col));
        }
        // } // E9DF
    }

    // E9F0
    private int handleFetchScreenAddress(int line){
        // E9F0 fetch screen address
        int low = memory.read(0xECF0 + line);
        memory.write(ADDRESS_CURRENT_SCREEN_LINE_ADDRESS,low);
        int high = 0xFF & (memory.read(0xD9+line) & 0x03);
        high |= memory.read(ADDRESS_TOP_OF_SCREEN_MEMORY);
        memory.write(0xD2, high);

        return low | (high << 8);
    }

    // EA24
    private int handleSetColorMemoryAddress(int currentScreenLineAddress){
        int low = currentScreenLineAddress & 0xFF;
        int high = ((currentScreenLineAddress >> 8) & 0x3) | 0xD8;
        memory.write(0xF3,low); // EA24 - EA26
        memory.write(0xF4,high); // EA28 - EA2E
        
        return low | (high << 8);
    
    }

    // E9E0
    private int handleSetColorAndScreenAddresses(int currentScreenLineAddress){
        int colorMemoryAddress = handleSetColorMemoryAddress(currentScreenLineAddress); //E9E0->EA24
        int low = memory.read(0xAC);
        memory.write(0xAE,low);
        
        int high = (memory.read(0xAD) & 0x3) | 0xD8;
        memory.write(0xAF, high);
        
        return low | (high << 8);
    }

    private void handleClearScreenLine(int line){
        int currentScreenLineAddress = handleFetchScreenAddress(line);
        int colorMemoryAddress = handleSetColorMemoryAddress(currentScreenLineAddress);
        int colorVal = memory.read(0x286);
        for (int column = 39; column >= 0; column--){
            memory.write(colorMemoryAddress + column, colorVal); // clear byte in color ram
            memory.write(currentScreenLineAddress + column, 0x20); // space
        }
        
        
    }        

    private void handleScrollScreen(){
        int currentScreenLineAddress = handleFetchScreenAddress(0);
        int[] data = new int[40];
        for (int line = 1; line <= 24; line++){
            memory.read(currentScreenLineAddress + 40,data);
            memory.write(currentScreenLineAddress,data);

            currentScreenLineAddress += 40;
        }
        handleClearScreenLine(24);
        //        memory.write(ADDRESS_CURSOR_LINE_NUMBER, (memory.read(ADDRESS_CURSOR_LINE_NUMBER) - 1) & 0xFF);
        writeRegister(RegisterType.X, memory.read(ADDRESS_CURSOR_LINE_NUMBER));
    }
    /**
     * Basically a port of what the assembly does (0xE8EA)
     */
    private void handleScrollScreen_old(){
        // E8EA - E8F5
        pushStack((byte)memory.read(0xAC));
        pushStack((byte)memory.read(0xAD));
        pushStack((byte)memory.read(0xAE));
        pushStack((byte)memory.read(0xAF));
        int tmp = 1;
        

        int accum = 0;
        int Y = 0;
        do { // E8F6
            int X = 255; // LABEL: E8F6
            memory.write(ADDRESS_CURSOR_LINE_NUMBER,(memory.read(ADDRESS_CURSOR_LINE_NUMBER) - 1) & 0xFF); // move up a line [DEC $D6]
            memory.write(ADDRESS_CURSOR_INPUT_X,(memory.read(ADDRESS_CURSOR_INPUT_X) - 1) & 0xFF); // input cursor X [DEC $C9]
            memory.write(ADDRESS_LINE_NUMBER_TEMP, (memory.read(ADDRESS_LINE_NUMBER_TEMP) - 1) & 0xFF); // temp line index [DEC $02A5]
            /*
            int topOfScreenMemory = 0xFF & memory.read(ADDRESS_TOP_OF_SCREEN_MEMORY);
            int currentScreenLineAddress = memory.read(ADDRESS_CURRENT_SCREEN_LINE_ADDRESS) | (memory.read(0xD2) << 8);
            int currentColorRamAddress = memory.read(0xF3) | (memory.read(0xF4) << 8);
            */
            X = (X + 1) & 0xFF; // E8FF [INX]
                // E900
                handleFetchScreenAddress(X); // [JSR $E9F0]
                
                // E903 [CPX #$18]
                if (X == 24){ // E905 [BCS $E913]
                    //                                        accum = memory.read(0xECF1 + line); // E907                   
                    memory.write(0xAC,memory.read(0xECF1 + X)); // E907 - E90A
                    //                    accum = 0xFF & memory.read(0xDA + line); // E90C
                    writeRegister(RegisterType.accumulator, memory.read(0xDA + X)); // E90C
                    handleMoveOneScreenLine(); // E90E [JSR $E9C8]
                } // E911
                // E913
                // E9FF clear one screen line
                //handleClearScreenLine(line);
                
                // E916
                for (int i = 0; i < 25; i++){
                    int v1 = memory.read(0xD9 + i) & 0x7F;
                    int v2 = memory.read(0xDA + i); // E91C
                    if ((v2 & 0x80) != 0){
                        v1 |= 0x80; // E920
                    }
                    memory.write(0xD9 + i, v1); // e922
            } // E927
            
            memory.write(0xF1, memory.read(0xF1) | 0x80); // E929 - E92D
            
            tmp = memory.read(0xD9);
        } while ((tmp & 0x80) == 0); // E931

        memory.write(ADDRESS_CURSOR_LINE_NUMBER, (memory.read(ADDRESS_CURSOR_LINE_NUMBER) + 1) & 0xFF);
        memory.write(ADDRESS_LINE_NUMBER_TEMP, (memory.read(ADDRESS_LINE_NUMBER_TEMP) + 1) & 0xFF);
        
        //        int keyscan = 0x7F;
        //memory.write(0xDC00,keyscan);
        //int keyVal = memory.read(0xDC01);
        //        e940://cmp #$FB
        /*
        execute_CMP(AddressingMode.Immediate, new int[] {0x00,0xFB}, memory, this);
        pushStack((byte) readRegister(RegisterType.status));
        writeRegister(RegisterType.accum, 0x7F);
        memory.write(0xDC00,keyscan);
        writeRegister(RegisterType.stsatus,popStack());

        if ((newVal & 0xFF) == 0){
            
        }
        */
        memory.write(0xC6, readRegister(RegisterType.Y));
        writeRegister(RegisterType.X, memory.read(ADDRESS_CURSOR_LINE_NUMBER));

        memory.write(0xAF, popStack());
        memory.write(0xAE, popStack());
        memory.write(0xAD, popStack());
        memory.write(0xAC, popStack());

    }
    private int toInt(int[] lowHigh){
        return (0xFF & lowHigh[0]) | ((0xFF & lowHigh[1]) << 8);
    }

    class InstructionBean{
        int address;
        Instruction instruction;
        int[] operands;
        public InstructionBean(int address, Instruction instruction, int[] operands){
            this.address = address;
            this.instruction = instruction;
            this.operands = new int[operands.length];
            System.arraycopy(operands, 0, this.operands,0,2);
        }

        void display(){
            System.out.println(Integer.toHexString(address) + " " + instruction.getFullAssemblyLine(instruction.getAddressingMode(),operands));
        }
    }
}

